= ValidationConfig DSL
Gopal S Akshintala <gopala.akshintala@salesforce.com>
:Revision: 1.0
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc:
:sourcedir: ../../vader/src/main/java
:testdir: ../../vader/src/test/java
:imagesdir: ../../images/config-dsl

== Flat

This is the simplest config for a _Single (Non-Batch)_ bean with flat Data-structure.

image:bean.png[]

=== Example

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
class Bean {
  String requiredField;
  ID sfIdFormatField;
  ID optionalSfIdFormatField;
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/BaseValidationConfigTest.java[tag=flat-bean]
----

endif::[]

==== Validation Requirements

* Configure to validate Mandatory fields.
* Configure to validate Fields for SF ID format.
* Configure other validators for the bean, written using one of `Validator*` types.

==== Demo

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
@DisplayName("Cases covered - Missing Field, String Field, List Field")
@Test
void failFastWithRequiredFieldsMissings() {
  final var validationConfig =
      ValidationConfig.<Bean, ValidationFailure>toValidate()
          .shouldHaveFieldsOrFailWith(
              Map.of(
                  Bean::getRequiredField1, REQUIRED_FIELD_MISSING_1,
                  Bean::getRequiredField2, REQUIRED_FIELD_MISSING_2,
                  Bean::getRequiredList, REQUIRED_LIST_MISSING))
          .shouldHaveValidSFIdFormatForAllOrFailWith(
              Map.of(
                  Bean::getSfId1, FIELD_INTEGRITY_EXCEPTION,
                  Bean::getSfId2, FIELD_INTEGRITY_EXCEPTION))
          .prepare();

  final var validatableWithBlankReqField = new Bean(0, "", null, null, List.of("1"));
  final var result1 = validateAndFailFast(validatableWithBlankReqField, validationConfig);
  assertThat(result1).contains(REQUIRED_FIELD_MISSING_2);

  final var validatableWithNullReqField = new Bean(null, "2", null, null, List.of("1"));
  final var result2 = validateAndFailFast(validatableWithNullReqField, validationConfig);
  assertThat(result2).contains(REQUIRED_FIELD_MISSING_1);

  final var validatableWithEmptyReqList = new Bean(1, "2", null, null, emptyList());
  final var result3 = validateAndFailFast(validatableWithEmptyReqList, validationConfig);
  assertThat(result3).contains(REQUIRED_LIST_MISSING);
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/ValidationConfigTest.java[tag=validationConfig-for-flat-bean-demo]
----

endif::[]

== Nested

image:bean-nested.png[]

This is a case where a bean of data-type, say `ContainerT`, contains (HAS-A) a member bean of data-type say `MemberT`.
Now validity of `ContainerT` depends on the validity of `MemberT`.
In such case, both the data-structures can be independently validated by providing different `ValidationConfig` objects to each data-types to the Runner API and the results can be composed for Fail-Fast, as shown below.
It supports nesting at any depth.

=== Example

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
class Bean {
  private final Integer requiredField1;
  private final String requiredField2;
  private final ID sfId1;
  private final ID sfId2;
}
class ContainerBean {
  String requiredField;
  Bean bean;
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/ValidationConfigTest.java[tag=nested-bean]
----

endif::[]

==== Validation Requirements

* Validate both data-structures independently.
* Compose their results for Fail-Fast.

==== Demo

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
@Test
void nestedBeanValidationWithInvalidMember() {
  final var memberValidationConfig =
      ValidationConfig.<Bean, ValidationFailure>toValidate()
          .shouldHaveValidSFIdFormatForAllOrFailWithFn(
              Tuple.of(
                  List.of(Bean::getSfId1, Bean::getSfId2),
                  (name, value) ->
                      getFailureWithParams(
                          ValidationFailureMessage.MSG_WITH_PARAMS, name, value)))
          .prepare();
  final var containerValidationConfig =
      ValidationConfig.<ContainerBean, ValidationFailure>toValidate()
          .shouldHaveFieldOrFailWithFn(
              ContainerBean::getRequiredField,
              (name, value) ->
                  getFailureWithParams(ValidationFailureMessage.MSG_WITH_PARAMS, name, value))
          .prepare();

  final var invalidSfId = new ID("invalidSfId");
  final var memberWithInvalidSfId =
      new Bean(null, null, new ID("1ttxx00000000hZAAQ"), invalidSfId);
  final var validContainer = new ContainerBean("requiredField", memberWithInvalidSfId);
  final var result =
      validateAndFailFast(
              validContainer,
              containerValidationConfig,
              ValidationFailure::getValidationFailureForException)
          .or(
              () ->
                  validateAndFailFast(
                      memberWithInvalidSfId,
                      memberValidationConfig,
                      ValidationFailure::getValidationFailureForException));

  assertThat(result).isPresent();
  assertThat(result.get().getValidationFailureMessage().getParams())
      .containsExactly(Bean.Fields.sfId2, invalidSfId);
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/ValidationConfigTest.java[tag=validationConfig-for-nested-bean-demo]
----

endif::[]
