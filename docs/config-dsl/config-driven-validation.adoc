= Config Driven Validation
Gopal S Akshintala <gopala.akshintala@salesforce.com>
:Revision: 1.0
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc:
:toc-placement: preamble
:sourcedir: ../../vader/src/main/java
:testdir: ../../vader/src/test/java
:imagesdir: ../images

Vader has a powerful and declarative Configuration DSL.
A config object is 1-1 mapped with a Data Structure, and holds all the information/requirements/specifications required to validate that Data-structure.
This is a powerful coz it lets you validate any Bean with any level or nesting, be it _Single_ or _Batch_.
It's easy to fit this model in our heads, as validation configuration aligns with Bean hierarchical-structure.

[.text-center]
image:hierarchical-validation.png[]

== What's a config DSL?

Config provides DSL methods (builder pattern) which guides you to prepare your Validation definition.
Depending on the context and your intent, there are different flavors of configs depending on these factors:

* Is the Data-structure under validation _Single (Non-Batch)_ or _Collection (Batch)_.
* Does the Data-structure HAS-A Nested-Data-structure which needs to be validated too.
** Is the Nested Data-structure _Single (Non-Batch)_ or _Collection (Batch)_.
* Does validations need to run from Container Context.

== Config DSL Flavors

Let's walk through each of these flavors with an example bean, validation requirements for its Data-structure and a demo for such requirements using a runnable JUnit test.

NOTE: These examples don't exhaustively cover all the use-cases.
You may refer the Javadoc of each validation config to find-out more.
Also, the unit tests should help with the usage of these fields.
As usual, file a git.soma issue if you have any new and unique use-cases.

=== link:ValidationConfig.adoc[ValidationConfig]

=== link:BatchValidationConfig.adoc[BatchValidationConfig]

=== link:NestedBatch1ValidationConfig.adoc[NestedBatch1ValidationConfig(TBD)]

=== link:BatchOfBatch1ValidationConfig.adoc[BatchOfBatch1ValidationConfig]

{empty} +

=== link:ContainerValidationConfig.adoc[ContainerValidationConfig]

=== link:ContainerValidationConfigWith2Levels.adoc[ContainerValidationConfigWith2Levels]

[#_containervalidationconfig_vs_validationconfig]
== `ContainerValidationConfig++*++` Vs `++*++ValidationConfig`

[.lead]
`ContainerValidationConfig++*++` talks about _what-it-contains_ and `++*++ValidationConfig` talks about _itself_.

Configuration fields like `shouldHaveMinBatchSizeOrFailWith, shouldHaveMaxBatchSizeOrFailWith` won't make sense when a `++*++ValidationConfig` is describing a Bean (or BeanBatch).
So these config parameters are separated-out into a different config under the umbrella of `ContainerValidationConfig++*++`

However, these can be confusing in scenarios like this:

[source,java,indent=0,options="nowrap"]
----
class ContainerWithMultiBatch {
  List<Bean1> batch1;
  List<Bean2> batch2;
}
----

In a data-structure you may have a validation like `batch1` should not be empty.
You can achieve this using both link:ContainerValidationConfig.adoc[ContainerValidationConfig] and link:BatchValidationConfig.adoc[BatchValidationConfig], with configs as below:

.Using link:ContainerValidationConfig.adoc[ContainerValidationConfig]
[source,java,indent=0,options="nowrap"]
----
ContainerValidationConfig.<ContainerWithMultiBatch, ValidationFailure>toValidate()
  .withBatchMapper(ContainerWithMultiBatch::getBatch1)
  .shouldHaveMinBatchSizeOrFailWith(Tuple.of(1, INVALID_BATCH_SIZE)).prepare();
----

.Using link:BatchValidationConfig.adoc[BatchValidationConfig]
[source,java,indent=0,options="nowrap"]
----
ValidationConfig.<ContainerWithMultiBatch, ValidationFailure>toValidate()
  .shouldHaveFieldOrFailWith(ContainerWithMultiBatch::getBatch1, FIELD_MISSING).prepare();
----

This similarity may cause confusion as to which one to use.
The answer is - *"It depends on your Intent"*.
If you look at the list being empty/`null` as `INVALID_BATCH_SIZE`, go with link:ContainerValidationConfig.adoc[ContainerValidationConfig].
If you look at it as any other mandatory field, go with link:BatchValidationConfig.adoc[BatchValidationConfig].

== `++*++ValidationConfig` DSL highlights

=== Stricter Salesforce `ID` Validation for Core consumers

One of the handy features of Vader, is to list all the `ID` fields of you bean that need validation at one place. 
This `ID` validation by default uses `com.force.swag.id.IdTraits.isValidIdStrictChecking(idStr, true)` utility.
But if you wish to have a more strict validation making use of the `EntityInfo` (For example, you can check if the `ID` field has specific prefix of the entity it represents),
you can do that too, using `IDConfig`. Let's understand that through an example:

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
class Bean {
  String requiredField;
  ID sfIdFormatField1;
  ID optionalSfIdFormatField2;
}

/**
* This represents `common.udd.EntityInfo` interface from core 
* which is implemented by all Entities.
*/
private interface EntityInfo {}

private static class Field1EntityInfo implements EntityInfo {}

private static class Field2EntityInfo implements EntityInfo {}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/BaseValidationConfigTest.java[tag=bean-with-id-fields]
----

endif::[]

==== Validation Requirements

* Both `ID` fields (`sfIdFormatField1`, `optionalSfIdFormatField2`) need to be validated `withIdValidator` passed by the consumer.

==== Demo

ifdef::env-github[]

[source,java,indent=0,options="nowrap"]
----
@Test
void idConfigForBatch() {
  final var field1EntityInfo = new Field1EntityInfo();
  final var field2EntityInfo = new Field2EntityInfo();
  final var config =
      BatchValidationConfig.<Bean, ValidationFailure>toValidate()
          .withIdConfig(
              IDConfig.<Bean, ValidationFailure, EntityInfo>toValidate()
                  .withIdValidator(BaseValidationConfigTest::uddUtil)
                  .shouldHaveValidSFIdFormatOrFailWith(Tuple.of(
                      Bean::getSfIdFormatField1, field1EntityInfo, INVALID_UDD_ID))
                  .absentOrHaveValidSFIdFormatOrFailWith(Tuple.of(
                      Bean::getOptionalSfIdFormatField2, field2EntityInfo, INVALID_OPTIONAL_UDD_ID))
                  .prepare())
          .prepare();
  final var validBean = new Bean(null, new ID("validId"), null);
  final var validatables = List.of(
      validBean,
      new Bean(null, new ID("invalidId"), null),
      new Bean(null, new ID("validId"), new ID("invalidId")));
  final var results = VaderBatch.validateAndFailFastForEach(validatables, config);
  assertThat(results)
      .containsExactly(right(validBean), left(INVALID_UDD_ID), left(INVALID_OPTIONAL_UDD_ID));
}

/**
 * This should be implemented by the client and passed through `withIdValidator` config.
 */
private static boolean uddUtil(ID idToValidate, EntityInfo entityInfo) {
  // A core client may use `common.udd.ValidIdUtil.isThisEntity(String, EntityIdInfo)`
  return !idToValidate.toString().equalsIgnoreCase("invalidId"); // fake implementation
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0,options="nowrap"]
----
include::{testdir}/org/revcloud/vader/runner/BaseValidationConfigTest.java[tag=bean-strict-id-validation]
----

endif::[]
