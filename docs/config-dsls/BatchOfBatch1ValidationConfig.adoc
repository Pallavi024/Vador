= BatchOfBatch1ValidationConfig DSL
Gopal S Akshintala <gopala.akshintala@salesforce.com>
:Revision: 1.0
:icons: font
:tip-caption: üí°
:caution-caption: ‚ö†Ô∏è
:sourcedir: ../../src/main/java
:testdir: ../../src/test/java
:imagesdir: ../../images
:sectnums:
:listing-caption: Snippet
:toc:
:toc-placement: preamble

If each of your _Batch_ bean, say `List<ContainerT>` HAS-A nested batch say `List<MemberT>`. The challenge is you may not want to validate both these batches independently, as they are inter-dependent 1(ContainerT):N(MemberT). Each `ContainerT` validity depends on all it's N nested `MemberT`s validity. But don't worry, the challenge is already solved by Vader. You just need to ask him to do it for you, by hooking `BatchValidationConfig<MemberT, FailureT>` into `BatchOfBatch1ValidationConfig<ContainerT, MemberT, FailureT>`.

== Example

ifdef::env-github[]

[source,java,indent=0]
----
class Root {
  List<Item> itemsBatch;
}

class Item {
  List<Bean> beanBatch;
}

class Bean {
  int value;
  String label;
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0]
----
include::{testdir}/org/revcloud/vader/runner/BatchOfBatch1ValidationConfigTest.java[tag=batch-of-batch-1]
----

endif::[]

To easily wrap your head around such data structure, visualise it like a *Tree*:

image:batch-of-batch-1.png[]

=== Validation Requirements

* Validate N Containers, and for each container, validate all its N Members.

=== Demo

ifdef::env-github[]

[source,java,indent=0]
----
@DisplayName(
  "Validate a structure like batchOf(Root[batchOf(bean)]) or like `List<Root<List<Bean>>`")
@Test
void nestedBatchFailFast() {
final var memberBatchValidationConfig =
    BatchValidationConfig.<Bean, ValidationFailure>toValidate()
        .withSpec(
            spec ->
                spec._2()
                    .when(Bean::getValue)
                    .matches(is(1))
                    .then(Bean::getLabel)
                    .shouldMatch(anyOf("1", "one"))
                    .orFailWith(INVALID_COMBO_1))
        .withValidator(ignore -> UNKNOWN_EXCEPTION, NONE)
        .prepare();
final var itemBatchValidationConfig =
    BatchOfBatch1ValidationConfig.<Item, Bean, ValidationFailure>toValidate()
        .withMemberBatchValidationConfig(
            Tuple.of(Item::getBeanBatch, memberBatchValidationConfig))
        .prepare();

final var invalidBean = new Bean(1, "a");
final var beanBatch = List.of(invalidBean, new Bean(1, "1"));
final var itemsBatch = List.of(new Item(beanBatch));
final var root = new Root(itemsBatch);

final var results =
    validateAndFailFastForEach(
        root.getItemsBatch(),
        itemBatchValidationConfig,
        NONE,
        ValidationFailure::getValidationFailureForException);
assertThat(results).hasSize(1);
final var result = results.get(0);
VavrAssertions.assertThat(result).isLeft();
final var failure = result.getLeft();
assertThat(failure.getContainerFailure()).isNull();
assertThat(failure.getBatchMemberFailures())
    .containsExactly(INVALID_COMBO_1, UNKNOWN_EXCEPTION);
}
----

endif::[]
ifndef::env-github[]

[source,java,indent=0]
----
include::{testdir}/org/revcloud/vader/runner/BatchOfBatch1ValidationConfigTest.java[tag=batch-of-batch-1-demo]
----

endif::[]
